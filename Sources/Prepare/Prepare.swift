import Foundation

let thisFileUrl = URL(fileURLWithPath: #filePath)
let rootDirectoryUrl = thisFileUrl.deletingLastPathComponent().deletingLastPathComponent().deletingLastPathComponent()
let geminiApiKey = getEnvironmentVariable("GEMINI_API_KEY")!
let remoteOpenAPIUrl = URL(string: "https://generativelanguage.googleapis.com/$discovery/OPENAPI3_0?version=v1&key=\(geminiApiKey)")!
let originalOpenAPIUrl = rootDirectoryUrl.appendingPathComponent("assets/original.json")
let outputOpenAPIUrl = rootDirectoryUrl.appendingPathComponent("assets/openapi.json")

@main
struct PrepareMain {
    static func main() throws {
        let originalOpenAPI = try! String(contentsOf: remoteOpenAPIUrl, encoding: .utf8)
        try! originalOpenAPI.write(to: originalOpenAPIUrl, atomically: true, encoding: .utf8)
        print("Saved original OpenAPI to \(originalOpenAPIUrl)")

        let newOpenAPI = originalOpenAPI.replacingOccurrences(of: ###"""
      "Part": {
        "properties": {
          "codeExecutionResult": {
            "description": "Result of executing the `ExecutableCode`.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CodeExecutionResult"
              }
            ]
          },
          "functionResponse": {
            "allOf": [
              {
                "$ref": "#/components/schemas/FunctionResponse"
              }
            ],
            "description": "The result output of a `FunctionCall` that contains a string\nrepresenting the `FunctionDeclaration.name` and a structured JSON\nobject containing any output from the function is used as context to\nthe model."
          },
          "fileData": {
            "description": "URI based data.",
            "allOf": [
              {
                "$ref": "#/components/schemas/FileData"
              }
            ]
          },
          "executableCode": {
            "description": "Code generated by the model that is meant to be executed.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ExecutableCode"
              }
            ]
          },
          "text": {
            "type": "string",
            "description": "Inline text."
          },
          "functionCall": {
            "allOf": [
              {
                "$ref": "#/components/schemas/FunctionCall"
              }
            ],
            "description": "A predicted `FunctionCall` returned from the model that contains\na string representing the `FunctionDeclaration.name` with the\narguments and their values."
          },
          "inlineData": {
            "description": "Inline media bytes.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Blob"
              }
            ]
          }
        },
        "type": "object",
        "description": "A datatype containing media that is part of a multi-part `Content` message.\n\nA `Part` consists of data which has an associated datatype. A `Part` can only\ncontain one of the accepted types in `Part.data`.\n\nA `Part` must have a fixed IANA MIME type identifying the type and subtype\nof the media if the `inline_data` field is filled with raw bytes."
      },
"""###, with: ###"""
      "TextPart": {
        "type": "object",
        "properties": {
          "text": {
            "type": "string",
            "description": "Inline text."
          }
        },
        "required": [
          "text"
        ]
      },
      "InlineDataPart": {
        "type": "object",
        "properties": {
          "inlineData": {
            "description": "Inline media bytes.",
            "$ref": "#/components/schemas/Blob"
          }
        },
        "required": [
          "inlineData"
        ]
      },
      "FunctionCallPart": {
        "type": "object",
        "properties": {
          "functionCall": {
            "description": "A predicted `FunctionCall` returned from the model that contains\na string representing the `FunctionDeclaration.name` with the\narguments and their values.",
            "$ref": "#/components/schemas/FunctionCall"
          }
        },
        "required": [
          "functionCall"
        ]
      },
      "FunctionResponsePart": {
        "type": "object",
        "properties": {
          "functionResponse": {
            "description": "The result output of a `FunctionCall` that contains a string\nrepresenting the `FunctionDeclaration.name` and a structured JSON\nobject containing any output from the function is used as context to\nthe model.",
            "$ref": "#/components/schemas/FunctionResponse"
          }
        },
        "required": [
          "functionResponse"
        ]
      },
      "FileDataPart": {
        "type": "object",
        "properties": {
          "fileData": {
            "description": "URI based data.",
            "$ref": "#/components/schemas/FileData"
          }
        },
        "required": [
          "fileData"
        ]
      },
      "ExecutableCodePart": {
        "type": "object",
        "properties": {
          "executableCode": {
            "description": "Code generated by the model that is meant to be executed.",
            "$ref": "#/components/schemas/ExecutableCode"
          }
        },
        "required": [
          "executableCode"
        ]
      },
      "CodeExecutionResultPart": {
        "type": "object",
        "properties": {
          "codeExecutionResult": {
            "description": "Result of executing the `ExecutableCode`.",
            "$ref": "#/components/schemas/CodeExecutionResult"
          }
        },
        "required": [
          "codeExecutionResult"
        ]
      },
      "Part": {
        "type": "object",
        "description": "A datatype containing media that is part of a multi-part `Content` message.\n\nA `Part` consists of data which has an associated datatype. A `Part` can only\ncontain one of the accepted types in `Part.data`.\n\nA `Part` must have a fixed IANA MIME type identifying the type and subtype\nof the media if the `inline_data` field is filled with raw bytes.",
        "oneOf": [
          {
            "$ref": "#/components/schemas/TextPart"
          },
          {
            "$ref": "#/components/schemas/InlineDataPart"
          },
          {
            "$ref": "#/components/schemas/FunctionCallPart"
          },
          {
            "$ref": "#/components/schemas/FunctionResponsePart"
          },
          {
            "$ref": "#/components/schemas/FileDataPart"
          },
          {
            "$ref": "#/components/schemas/ExecutableCodePart"
          },
          {
            "$ref": "#/components/schemas/CodeExecutionResultPart"
          }
        ]
      },
"""###)
        
        // Save original OpenAPI to output file
        assert(newOpenAPI != originalOpenAPI)
        try! newOpenAPI.write(to: outputOpenAPIUrl, atomically: true, encoding: .utf8)

        // Generate Swift code from OpenAPI
        try runCommand("make generate-openapi")
    }
}